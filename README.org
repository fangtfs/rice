#+title: PEW - Peromage's Emacs Workspace
#+author: Peromage

#+begin_quote
A minimalist's Emacs configuration.
#+end_quote

* About
This is my personal Emacs configuration.  Be aware that it might not fit your needs.

This configuration intends to be as minimal as possible so it prioritizes using Emacs built-in functionalities.

For convenience, I've included my [[https://github.com/peromage/rice][personal configuration collection]] in [[./rice][rice]] directory which is synchronized regularly via =git subtree=.

* Features
- Modular
- Lightweight and quick
- Minimal init support (Emacs built-int packages only)
- Terminal friendly
- Respect Emacs vanilla key bindings
- Evil mode enabled mainly for editing buffers (no =evil-collection=)
- Vertico and its complementary packages as completion framework
- LSP enabled
- Emacs 28+ only

* Get started
Clone this repository to =~/.emacs.d=.

#+begin_src shell
$ git clone https://github.com/peromage/pew.git ~/.emacs.d
#+end_src

Then Emacs will automatically install everything for you.

** Option 1 -- Clone to ~/.emacs.d
This is the traditional way to use this configuration.  Simply clone this repo to =~/.emacs.d=.

#+begin_src sh
git clone https://github.com/peromage/pew.git ~/.emacs.d
#+end_src

** Option 2 -- Clone to somewhere else
This configuration also supports loaded from non-canonical path.

#+begin_src sh
git clone https://github.com/peromage/pew.git ~/pew
#+end_src

While in the =init.el=,

#+begin_src elisp
(load-file "~/pew/init.el")
#+end_src

** Local configuration files
There are two local configuration files which are not tracked by default.

/custom.el/ (/custom-mini.el/ if ~pew::mini-init~ is non-nil): This file contains all the customization set from ~customize~ interface.  Some settings that wishes not to be tracked can be put here.  This file is loaded at the last.

/early-custom.el/: This file is loaded before any other configurations.  Can be used to override some configuration variables.

** List of files and directories

#+begin_example
pew
├── lisp/                   # Configuration files
├── site-lisp/              # Addtional package files written by myself
├── yasnippets/             # Snippet files loaded by yasnippet
├── rice/                   # My config collection for other apps
├── scripts/                # Test scripts
├── early-init.el           # Init file loaded before init.el
├── init.el                 # Main init file
├── .pew                    # Configuration root placeholder
├── .gitignore              # Git ignore file
├── LICENSE                 # License file
└── README.org              # This file
#+end_example

* My customizations
The idea of modular structure was borrowed from [[https://github.com/purcell/emacs.d][Steve Purcell]]'s Emacs configuration.

** Package management
I've tried my best to avoid cross references between modules so they can be used individually (except =init-common.el=).

Package management uses built-in =package.el= and helper macro [[https://github.com/jwiegley/use-package][use-package]].  I might switch to use [[https://github.com/radian-software/straight.el][straight.el]] if there are demands in the future.

For =use-package=, =use-package-always-ensure= is enabled so packages will be installed automatically.

** pewcfg
I developed this macro to help myself configure Emacs built-in functionalities in a =use-package= fashion.  Here is a list of keywords.

| Keyword      | Description                                                           |
|--------------+-----------------------------------------------------------------------|
| ~:custom~    | Set variable values that can be configured with custom interface.     |
| ~:map~       | Set key bindings in a new map.                                        |
| ~:bind~      | Set key bindings in an existing map.                                  |
| ~:transient~ | Similar with :map but also define a command to trigger transient map. |
| ~:switch~    | Define a command to toggle variable values.                           |
| ~:face~      | Set face attributes.                                                  |
| ~:property~  | Set variable properties.                                              |
| ~:hook~      | Set hook functions.                                                   |
| ~:automode~  | Set auto mode triggers.                                               |
| ~:eval~      | Evaluate forms.                                                       |

Examples see [[./lisp/init-defaults.el][init-defaults.el]]

** Emacs state key bindings
To respect Emacs key bindings, I've tried only a few modification on the original ones.  Most of them are just enhancement without changing the meanings.

My personal key bindings mostly are bound in ~pewkey-map~. It can be activated by ~pewkey~ and ~pewkey-repeat~.

Key bindings for packages are accessed by ~C-c~ prefix. I try to make it mnemonic.

| Command                                                    | Prefix        | Definition                                   |
|------------------------------------------------------------+---------------+----------------------------------------------|
| ~pewkey~                                                   | =C-x C-x=     | [[./lisp/init-defaults.el][init-default.el]] |
| ~pewkey-repeat~                                            | =C-u C-x C-x= | [[./lisp/init-defaults.el][init-default.el]] |
| Line @@html:<b>@@S@@html:</b>@@earch by ~consult~          | =C-c s=       | [[./lisp/elpa-vertico.el][elpa-vertico.el]]  |
| Mini@@html:<b>@@B@@html:</b>@@uffer by ~consult~           | =C-c b ...=   | [[./lisp/elpa-vertico.el][elpa-vertico.el]]  |
| @@html:<b>@@G@@html:</b>@@it by ~magit~                    | =C-c g ...=   | [[./lisp/elpa-git.el][elpa-git.el]]          |
| @@html:<b>@@L@@html:</b>@@SP by ~lsp-mode~                 | =C-c l ...=   | [[./lisp/elpa-lsp.el][elpa-lsp.el]]          |
| Jump @@html:<b>@@W@@html:</b>@@indow by ~ace-window~       | =C-c w=       | [[./lisp/elpa-utils.el][elpa-utils.el]]      |
| Find @@html:<b>@@C@@html:</b>@@haracter by ~avy-goto-char~ | =C-c f=       | [[./lisp/elpa-utils.el][elpa-utils.el]]      |
| @@html:<b>@@J@@html:</b>@@ump to line by ~avy-goto-line~   | =C-c j=       | [[./lisp/elpa-utils.el][elpa-utils.el]]      |
| Separate edit by ~separedit~                               | =C-c '=       | [[./lisp/elpa-utils.el][elpa-utils.el]]      |

** Evil mode key bindings
Evil leader key is bound with =\= as a "secondary" leader since most of the bindings are from ~pewkey~ under =SPC= to keep habit consistent.

The local leader is not used frequently so I leave it undefined.

| Command         | Key binding (normal and visual state) |
|-----------------+---------------------------------------|
| Leader          | =\=                                   |
| Local leader    | N/A                                   |
| ~pewkey~        | =SPC=                                 |

See [[./lisp/elpa-evil.el][elpa-evil.el]] for Evil bindings.

** Naming convention
Since Elisp doesn't support namespace, it's a little painful to distinguish symbol names from other packages.  Although the traditional recommendation is to prefix variables and functions with the package name and use dash only to separate the actual names, I found it's not very intuitive.

I decided to add some personal tastes also try to keep it simple. Complicated rules may make it hard to remember and cause inconsistency.

Xah Lee had a [[http://xahlee.info/emacs/misc/elisp_naming_convention.html][discussion]] on this.

Also, worth trying [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Shorthands.html][Shorthands]] if the variable prefix is too long.

*** Namespace separator =::=
I prefer C++ style when it comes to namespace.

For example:
- ~pew::foo::bar~

*** Variable and function names
ELisp naming convention should suffice in this case.  Namespace can be prefixed if needed.

For example:
- ~some-awesome-symbol~
- ~pew::symbol-with-namespace~

*** Function parameters
For now it keeps consistent with [[*Variable and function names]].  However, I also consider moving to use Camel style in the future.

For example:
- ~(defun foo (one-param another-one))~
- ~(defun bar (OneParam AnotherOne))~ -- maybe

*** Let bound variables =l:= =ql:=
For the scoped variables, I use =l:= prefix and =ql:= for the variables that are in a quoted list.

For example:
- ~(let ((l:local-foo "something") (l:local-bar 123)))~
- ~`(let ((ql:local-foo "something") (ql:local-bar 123)))~

*** Unused variables
Prefix the unused variables just like Python.

For example:
- ~(defun foo (take-this _ignored))~


** Format convention
*** Comments
In-line comment starts with two semicolons followed by a space at the same indentation of the code. e.g. =;; something=.

If commenting out a line of code, prepend two semicolons without spaces. e.g. =;;(form)=.

Divider comment start at least three semicolons followed by a space. The number of semicolons depends on the depth. e.g. =;;; A divider line=.

*** use-package keyword order
I prefer this declaration order when configuring with =use-package=.

If a keyword occupies more than one line, put an empty line before and after it.

|------------------+-------------|
| Description      | Keyword     |
|------------------+-------------|
| Always enabled   | ~:demand~   |
|                  | ~:ensure~   |
|------------------+-------------|
| Cause deferral   | ~:defer~    |
|                  | ~:if~       |
|                  | ~:requires~ |
|                  | ~:after~    |
|                  | ~:commands~ |
|------------------+-------------|
| Bindings         | ~:mode~     |
|                  | ~:bind~     |
|                  | ~:hook~     |
|------------------+-------------|
| Loaded anyway    | ~:init~     |
|------------------+-------------|
| Customization    | ~:custom~   |
|------------------+-------------|
| On module loaded | ~:config~   |
|------------------+-------------|

*** use-package keyword spacing
Usually each keyword section should be surrounded by an empty line if it takes more than one line.

However, if the keyword section takes only one line, then multiple keywords that follow the same fashion can be put together without spacing. For example

#+begin_src elisp
(use-package foo
  :ensure t
  :defer nil
  :requires bar

  :init
  (form1)
  (form2)

  :config
  (form3)
  (form4))
#+end_src

* Literal configuration?
Short answer is no.

I've seen a lot people put their configs in a giant org file and render it in a nice web page.  Looks cool but I think I'm still an old-fashioned guy who likes to code in a traditional way.  Code re-usability is important for me.  And haven't mentioned that proper comments with =outline-mode= can also make code easy to navigate.

* Acknowledgement
This configuration is inspired by
- [[https://github.com/purcell/emacs.d][purcell/emacs.d]]
- [[https://github.com/protesilaos/dotfiles][protesilaos/dotfiles]]
- [[https://github.com/condy0919/.emacs.d][condy0919/.emacs.d]]
