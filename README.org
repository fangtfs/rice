#+title: PEW - Peromage's Emacs Workbench
#+author: Peromage

#+begin_quote
A minimalist's Emacs configuration.
#+end_quote

* About
This is my personal Emacs configuration.  Be aware that it might not fit your needs.

This configuration intends to be as minimal as possible so it prioritizes using Emacs built-in functionalities.

For convenience, I've included my [[https://github.com/peromage/rice][personal configuration collection]] in [[./rice][rice]] directory which is synchronized regularly via =git subtree=.

* Features
- Modular
- Lightweight and quick
- Minimal init support (Emacs built-int packages only)
- Terminal friendly
- Respect Emacs vanilla key bindings
- Evil mode enabled mainly for editing buffers (no =evil-collection=)
- Vertico and its complementary packages as completion framework
- LSP enabled
- Emacs 28+ only

* Get started
Clone this repository to =~/.emacs.d=.

#+begin_src shell
$ git clone https://github.com/peromage/pew.git ~/.emacs.d
#+end_src

Then Emacs will automatically install everything for you.

** Temporary file
Disposable changes will be in =~/.emacs.d/local.el= including settings from ~customize~.

=local.el= will be applied on top of the default pew configuration.

** List of files and directories

#+begin_example
pew
├── lisp/                   # Configuration files
├── site-lisp/              # Addtional package files written by myself
├── yasnippets/             # Snippet files loaded by yasnippet
├── rice/                   # My config collection for other apps
├── tests/                  # Test scripts
├── early-init.el           # Init file loaded before init.el
├── init.el                 # Main init file
├── .pew                    # Configuration root placeholder
├── .gitignore              # Git ignore file
├── LICENSE                 # License file
└── README.md               # This file
#+end_example

* My customizations
The idea of modular structure was borrowed from [[https://github.com/purcell/emacs.d][Steve Purcell]]'s Emacs configuration.

** Package management
I've tried my best to avoid cross references between modules so they can be used individually (except =init-common.el=).

Package management uses built-in =package.el= and helper macro [[https://github.com/jwiegley/use-package][use-package]].  I might switch to use [[https://github.com/radian-software/straight.el][straight.el]] if there are demands in the future.

For =use-package=, =use-package-always-ensure= is enabled so packages will be installed automatically.

** pew/config
I developed this macro to help myself configure Emacs built-in functionalities in a =use-package= fashion.  Here is a list of keywords.

| Keyword    | Description                                                           |
|------------+-----------------------------------------------------------------------|
| :custom    | Set variable values that can be configured with custom interface.     |
| :map       | Set key bindings in a map.                                            |
| :bind      | Set key bindings.                                                     |
| :transient | Similar with :map but also define a command to trigger transient map. |
| :switch    | Define a command to toggle variable values.                           |
| :face      | Set face attributes.                                                  |
| :property  | Set variable properties.                                              |
| :hook      | Set hook functions.                                                   |
| :eval      | Evaluate forms.                                                       |

Examples see [[./lisp/init-defaults.el][init-defaults.el]]

** Emacs state key bindings
To respect Emacs key bindings, I've tried only a few modification on the original ones.  Most of them are just enhancement without changing the meanings.

My personal key bindings mostly are bound in =pewkey-map=. It can be activated by =pewkey= and =pewkey-repeat=.

Key bindings for packages are accessed by ~C-c~ prefix. I try to make it mnemonic.

| Command                                             | Prefix      | Definition                                   |
|-----------------------------------------------------+-------------+----------------------------------------------|
| ~pewkey~                                            | ~C-x g~     | [[./lisp/init-defaults.el][init-default.el]] |
| ~pewkey-repeat~                                     | ~C-x G~     | [[./lisp/init-defaults.el][init-default.el]] |
| Line @@html:<b>@@S@@html:</b>@@earch with ~consult~ | ~C-c s~     | [[./lisp/elpa-vertico.el][elpa-vertico.el]]  |
| Mini@@html:<b>@@B@@html:</b>@@uffer with ~consult~  | ~C-c b ...~ | [[./lisp/elpa-vertico.el][elpa-vertico.el]]  |
| @@html:<b>@@G@@html:</b>@@it with ~magit~           | ~C-c g ...~ | [[./lisp/elpa-git.el][elpa-git.el]]          |
| @@html:<b>@@L@@html:</b>@@SP with ~lsp-mode~        | ~C-c l ...~ | [[./lisp/elpa-lsp.el][elpa-lsp.el]]          |

** Evil mode key bindings
Evil leader key is bound with ~DEL~ and local leader key with ~\~.  Most of bindings is the same with =pewkey=.

| Command         | Key binding (normal and visual state) |
|-----------------+---------------------------------------|
| Leader          | ~DEL~                                 |
| Local leader    | ~\~                                   |
| ~pewkey~        | ~SPC~                                 |
| ~pewkey-repeat~ | ~RET~                                 |

See [[./lisp/elpa-evil.el][elpa-evil.el]] for Evil bindings.

** Naming Convention
Since Elisp doesn't support namespace, it's a little painful to distinguish symbol names from other packages.  Although the traditional recommendation is to prefix variables and functions with the package name and use dash only to separate the actual names, I found it's not very intuitive.

I decided to add some personal tastes but I try to keep it simple. Complicated rules may make it hard to remember and cause inconsistency.

| Scope                                  | Convention                                 | Example                             |
|----------------------------------------+--------------------------------------------+-------------------------------------|
| Namespace separator                    | /                                          | pew/foo/bar                         |
| Function name separator                | -                                          | pew/some-func                       |
| Function parameters                    | Follow normal variable naming convention   | (defun foo (one-param another-one)) |
| Let bound variables                    | Prefix with ~l/~ and use ~-~ as separator  | (let ((l/local-bound)))             |
| Let bound variables in macro expansion | Prefix with ~lm/~ and use ~-~ as separator | `(let ((lm/local-bound-in-macro)))  |
| Unused variables                       | Prefix with ~_~                            | (defun bar (first _ignored))        |

Xah Lee had a [[http://xahlee.info/emacs/misc/elisp_naming_convention.html][discussion]] on this.

** use-package keyword order
I prefer this declaration order when configuring with =use-package=.

If a keyword occupies more than one line, put an empty line before and after it.

|------------------+-----------|
| Description      | Keyword   |
|------------------+-----------|
| Always enabled   | :demand   |
|                  | :ensure   |
|------------------+-----------|
| Cause deferral   | :defer    |
|                  | :if       |
|                  | :requires |
|                  | :after    |
|                  | :commands |
|------------------+-----------|
| Bindings         | :mode     |
|                  | :bind     |
|                  | :hook     |
|------------------+-----------|
| Loaded anyway    | :init     |
|------------------+-----------|
| Customization    | :custom   |
|------------------+-----------|
| On module loaded | :config   |
|------------------+-----------|

* Literal configuration?
Short answer is no.

I've seen a lot people put their configs in a giant org file and render it in a nice web page.  Looks cool but I think I'm still an old-fashioned guy who likes to code in a traditional way.  Code re-usability is important for me.  And haven't mentioned that proper comments with =outline-mode= can also make code easy to navigate.

* Acknowledgement
This configuration is inspired by
- [[https://github.com/purcell/emacs.d][purcell/emacs.d]]
- [[https://github.com/protesilaos/dotfiles][protesilaos/dotfiles]]
- [[https://github.com/condy0919/.emacs.d][condy0919/.emacs.d]]
